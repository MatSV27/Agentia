{
  "fix": "Cambiar el código de la función login en app.py",
  "changes": [
    {
      "file": "app.py",
      "lines": "135-174",
      "original": "# Endpoint de login\n@app.route('/api/login', methods=['POST'])\ndef login():\n    data = request.get_json()\n    email = data.get('email')\n    password = data.get('password')\n    conn = get_db_connection()\n    if conn is None:\n        return jsonify({'message': 'Error de conexión a la base de datos'}), 500\n    cur = conn.cursor()\n    try:\n        cur.execute('SELECT * FROM users WHERE email = %s', (email,))\n        user = cur.fetchone()\n        if not user:\n            return jsonify({'message': 'Usuario no encontrado'}), 400\n        \n        # Imprimir información de depuración\n        print(f\"Contraseña proporcionada: {password}\")\n        print(f\"Hash almacenado: {user[3]}\")\n        \n        try:\n            # Convertir el hash hexadecimal a bytes\n            stored_hash = user[3]\n            if stored_hash.startswith('\\\\x'):\n                # Quitar el prefijo \\x y convertir de hex a bytes\n                stored_hash = bytes.fromhex(stored_hash[2:])\n            else:\n                stored_hash = stored_hash.encode('utf-8')\n            \n            # Verificar la contraseña\n            if not bcrypt.checkpw(password.encode('utf-8'), stored_hash):\n                return jsonify({'message': 'Contraseña incorrecta'}), 400\n        except ValueError as e:\n            print(f\"Error al verificar la contraseña: {e}\")\n            return jsonify({'message': f'Error al verificar la contraseña: {e}'}), 500\n        \n        token = jwt.encode({'id': user[0]}, JWT_SECRET, algorithm='HS256')\n        return jsonify({'token': token, 'name': user[1]}), 200",
      "corrected": "# Endpoint de login\n@app.route('/api/login', methods=['POST'])\ndef login():\n    data = request.get_json()\n    email = data.get('email')\n    password = data.get('password')\n    conn = get_db_connection()\n    if conn is None:\n        return jsonify({'message': 'Error de conexión a la base de datos'}), 500\n    cur = conn.cursor()\n    try:\n        cur.execute('SELECT * FROM users WHERE email = %s', (email,))\n        user = cur.fetchone()\n        if not user:\n            return jsonify({'message': 'Usuario no encontrado'}), 400\n        \n        # Imprimir información de depuración\n        print(f\"Contraseña proporcionada: {password}\")\n        print(f\"Hash almacenado: {user[3]}\")\n        \n        try:\n            # Usar check_password_hash de Werkzeug para verificar la contraseña\n            # ya que generate_password_hash se usó para crear el hash en el registro\n            if not check_password_hash(user[3], password):\n                return jsonify({'message': 'Contraseña incorrecta'}), 400\n        except ValueError as e:\n            print(f\"Error al verificar la contraseña: {e}\")\n            return jsonify({'message': f'Error al verificar la contraseña: {e}'}), 500\n        \n        token = jwt.encode({'id': user[0]}, JWT_SECRET, algorithm='HS256')\n        return jsonify({'token': token, 'name': user[1]}), 200"
    }
  ],
  "explanation": "El problema está en la verificación de la contraseña durante el login. La función de registro usa 'generate_password_hash' de Werkzeug, pero la función de login intenta verificar usando 'bcrypt.checkpw' directamente, lo que causa el error 'Invalid salt'. La solución es usar 'check_password_hash' de Werkzeug en lugar de 'bcrypt.checkpw', ya que es el complemento correcto para 'generate_password_hash'."
} 